# 实验3：Rust 命令行解释器实现

*   **班级**: 软2306
*   **姓名**: 王贝迪
*   **学号**: 20232241399

## 2. 引言

### 2.1 命令行解释器 (CLI / Shell) 概述

命令行解释器（Command Line Interpreter，简称CLI）或更广为人知的“Shell”，是一种操作系统或应用程序与用户之间进行交互的界面。它接收用户输入的命令，然后将这些命令解析并执行。Shell 的核心功能是读取、解析和执行命令，并将执行结果返回给用户。它是 Unix-like 系统（如 Linux）用户与内核沟通的桥梁。

一个典型的 Shell 功能包括：
1.  **读取 (Read)**：从用户那里读取一行输入。
2.  **解析 (Parse)**：将输入的字符串分解成命令名、参数、重定向、管道等组成部分。
3.  **执行 (Execute)**：根据解析结果，执行对应的程序或内置命令。
4.  **循环 (Loop)**：不断重复上述过程，直到用户退出。

### 2.2 本实验目标

本次实验旨在从零开始，使用 Rust 语言实现一个简化的命令行解释器。通过实现，我们将深入理解 Shell 的工作原理，并掌握 Rust 在系统编程、进程管理和错误处理方面的能力。

具体目标包括：
*   在 Linux 环境下运行。
*   支持对命令及其参数的解析。
*   健壮的错误处理机制。
*   （可选但实现）支持类似 Unix 的命令间管道（`|`）机制。

## 3. 设计（gemini 2.5 pro 设计）

### 3.1 总体架构

本命令行解释器采用经典的“读-解析-执行”循环模型。其主要模块和交互流程如下：

```
+----------------+
|                |
|      Main Loop |
|                |
+--------+-------+
         |
         | (1) Read Line (std::io::stdin)
         V
+--------+-------+
|                |
|  Input Parser  | (2) Parse Command & Arguments, Handle Pipes
|                |
+--------+-------+
         |
         | (3) Command Representation (e.g., Vec<Vec<String>>)
         V
+--------+-------+
|                |
| Command Executor | (4) Execute Built-in or External Commands
|                |     (std::process::Command)
+--------+-------+
         |
         | (5) Output/Error Handling (eprintln!)
         V
+--------+-------+
|                |
|      Loop back |
|                |
+----------------+
```

### 3.2 模块设计

本Shell主要由以下几个核心功能模块组成：

1. **`main` 函数 (主循环)**：

   *   负责显示提示符 (`shell> `)。
   *   调用 `std::io::stdin().read_line()` 读取用户输入。
   *   对读取到的输入进行预处理（如 `.trim()`）。
   *   调用解析模块。
   *   调用执行模块。
   *   处理执行结果和错误，并打印信息。
   *   循环执行直到用户输入 `exit` 或 `Ctrl+D`。

2. **`parse_input` 函数 (输入解析器)**：

   *   **职责**：将原始用户输入字符串解析成结构化的命令表示。
   *   **挑战**：需要处理空格作为分隔符，同时又要支持带引号的参数（例如 `echo "hello world"`），以及管道符 `|`。
   *   **实现思路**：
       *   首先，根据管道符 `|` 将整行输入拆分为多个“命令片段”。
       *   然后，对每个命令片段，进一步解析其内部的命令名和参数。这个解析过程需要一个状态机来识别是否在引号内，以正确处理包含空格的参数。
       *   返回一个 `Vec<Vec<String>>` 类型，其中外层 `Vec` 代表管道中的各个命令，内层 `Vec` 代表单个命令的参数列表（第一个元素是命令名）。

3. **`execute_command_pipeline` 函数 (命令执行器)**：

   * **职责**：接收解析后的命令结构，并执行相应的命令或命令管道。

   * **内置命令处理**：

     *   `exit`: 终止 Shell 进程。
     *   `cd`: 改变当前工作目录。这是一个重要的内置命令，因为外部进程无法改变 Shell 自身的当前工作目录。

   * **外部命令处理**：

     *   使用 `std::process::Command` API 来创建和管理子进程。
     *   设置命令名和参数。
     *   **管道实现**：
         *   对于管道中的第一个命令，其标准输出需要被重定向到管道中。
         *   对于管道中的中间命令，其标准输入来自上一个命令的标准输出，其标准输出重定向到管道中。
         *   对于管道中的最后一个命令，其标准输入来自上一个命令的标准输出，其标准输出通常是 Shell 的标准输出。
         *   需要存储每个子进程的 `Child` 句柄，并在所有命令启动后，等待它们全部完成。

   * **错误处理**：捕获 `Command::spawn()` 可能返回的错误（如 `command not found`），并友好的报告给用户。

     







---